代理模式___静态代理

<静态代理>：
      在编译前需要手动编写代理类，当程序编译运行时就创建代理类，在创建代理类时候，需要创建委托类的引用，
      代理类也需要实现和委托类一样的接口，在接口方法中通过委托类的引用来调用执行委托类中的接口方法；



代理模式___动态代理

**<静态代理的弊端>：
    --当我通过代理类执行委托类实现的方法时，有时因为需要我需要进行一些额外的处理，那么我就需要将代理类中的方法全部添加额外的处理，
    --这样会增加代码量，同时使得我们的代码复用性不好，为了解决这个问题，我就可以应用动态代理；
       
 <动态代理>：
        在编写程序时，无需我手动编写代理类，通过Proxy类的静态方法newProxyInstance(loader,interface,object)方法，可以帮我创建一个代理类，
        它是我指定的委托类的代理类（通过我传过去的指定的委托类object）,然后通过编写一个实现了InvocationHandler接口的中介类，
        这个中介类需要做的就是让代理实例执行方法调用并返回一个处理结果（重写的invoke(proxy，method，args)方法，proxy是我的代理类实例，
        method是代理类要执行的方法，args是方法的参数），在invoke（）方法中，指定method对象的invoke（）方法，来返回处理结果，在这之前或者之后，
        都可以执额外的处理；

       <问题>
       ---有个问题，我们创建的代理类实例，是如何通过invoke（）方法来执行指定的方法的？
        ---答：
        ①.OwnFactory factory = new OwnFactory("达利园");
        ②. InvocationHandler commission = new Mediation(factory);
        ③.Factory factory_Agent = (Factory) Proxy.newProxyInstance(factory.getClass().getClassLoader(),
        new Class[]{Factory.class},commission);
        ④.factory_Agent.produce();
        A：当执行①过程时，我们创建了委托类的一个实例；
        B：执行②过程时，创建了一个InvocationHandler类型的中介类实例，这个中介类实例中，包含了对方法的额外处理；
        *1.通过中介类的构造方法创建中介类实例时执行了以下过程，中介类构造方法接收的是委托类实例，将中介类中的委托类对象初始化；

        C：执行③过程时，首先通过Proxy类创建了一个代理类（这个代理类继承了Proxy类，实现了委托类实现的接口，类似于静态代理中手动编写代理类的过程，
        三个参数分别是委托类的类加载器，委托类实现的接口，中介类实例），

        *2.代理类接收中介类实例，当实例化这个代理类时，在代理的构造方法中，会将代理类实例初始化为中介类的实例对象
        D：执行④过程时，会返回中介类方法的执行结果
        *3.，当代理类实例实现接口方法时，会通过调用中介类实例中的invoke（）方法来返回方法的执行结果；

<动态代理和静态代理相比>：
        
        静态代理是简单的代理类代理委托类，而动态代理，会通过一个实现了InvocationHandler接口的中介类来给委托类添加额外处理，
        通过Proxy的newProxyInstance方法返回一个代理类实例，这个代理类实例包含了中介类实例，而中介类实例中有包含了委托类的实例，通过间接的关系，
        代理类实现接口方法时，是隐式地让中介类来执行方法调用；
        
        
        -------------------如有理解有误的地方，欢迎指正----------------------------
